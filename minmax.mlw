use int.Int
use int.MinMax
use mach.int.Int63
use list.List
use list.Reverse
use list.Append
use list.HdTl
use list.FoldLeft
use list.Mem
use ref.Ref

type arbre 'a =
| N 'a (list (arbre 'a))

exception Return int

let function int63_min (a b:int63) =
  ensures { result = a \/ result = b  }
  ensures { result <= a /\ result <= b }
  if a < b then a else b
  
let function int63_max (a b:int63) =
  ensures { result = a \/ result = b  }
  ensures { result >= a /\ result >= b }
  if a > b then a else b
   
predicate sub_list (l1 l2:list 'a) =
  forall x:'a. mem x l2 -> mem x l1


let rec function height (a:arbre 'a) =
  variant { a }
  ensures { result >= 0 }
  match a with
  | N _ Nil -> 0
  | N _ l -> 1 + height_list l
  end
with function height_list (l:list (arbre 'a)) = 
  variant { l }
  ensures { result >= 0 }
  match l with
  | Nil -> 0
  | Cons e l' -> max (height e) (height_list l')
  end

let rec lemma height_list_max (l:list (arbre 'a)) =
  variant { l }
  ensures { forall x. mem x l -> height x <= height_list l }
  match l with
  | Nil -> ()
  | Cons _ l' -> height_list_max l'
  end


let rec function minmax' (f:'a -> int63) (t:arbre 'a) (bo:bool) =
  variant { t }
  match t with
  | N info Nil -> f info
  | N _ l -> 
    minmax'_list f bo l (if bo then min_int else max_int)
  end
with function minmax'_list f bo ll v =
  variant { ll }
  match ll with
  | Nil -> v
  | Cons e l' -> 
    let v' =  (if bo then int63_max else int63_min) v (minmax' f e (not bo)) in
    minmax'_list f bo l' v'
  end

(* MINMAX LIST LEMMA IN *)
let rec lemma minmax'_list_max_in (f: 'a -> int63) (l: list (arbre 'a)) (v:int63) =
  variant { l }
  ensures {
    let score = minmax'_list f true l v in
    (v=score \/ (exists e. mem e l /\ minmax' f e false = score)) /\ score>=v
  }
  match l with
  | Nil -> ()
  | Cons e l' ->
    let v1 = minmax' f e false in
    if v1 > v then
      minmax'_list_max_in f l' v1
    else
      minmax'_list_max_in f l' v
  end
  
let rec lemma minmax'_list_min_in (f: 'a -> int63) (l: list (arbre 'a)) (v:int63) =
  variant { l }
  ensures {
    let score = minmax'_list f false l v in
    (v=score \/ exists e. mem e l /\ minmax' f e true = score) /\ score<=v
  }
  match l with
  | Nil -> ()
  | Cons e l' ->
    let v1 = minmax' f e true in
    if v1 < v then
      minmax'_list_min_in f l' v1
    else
      minmax'_list_min_in f l' v
  end

(* MINMAX LIST LEMMA MIN-MAX *)
let rec lemma mimax'_list_max
  (f: 'a -> int63) (l: list (arbre 'a)) (v:int63) =
  variant { l }
  ensures {
    let score = minmax'_list f true l v in
    forall e:arbre 'a. mem e l -> score >= minmax' f e false
  }
  match l with
  | Nil -> ()
  | Cons e l' ->
    let v1 = minmax' f e false in
    if v1 >= v then
      mimax'_list_max f l' v1
    else
      mimax'_list_max f l' v
  end

let rec lemma mimax'_list_min
  (f: 'a -> int63) (l: list (arbre 'a)) (v:int63) =
  variant { l }
  ensures {
    let score = minmax'_list f false l v in
    forall e:arbre 'a. mem e l -> score <= minmax' f e true
  }
  match l with
  | Nil -> ()
  | Cons e l' ->
    let v1 = minmax' f e true in
    if v1 <= v then
      mimax'_list_min f l' v1
    else
      mimax'_list_min f l' v
  end
 



(* MINMAX BOUND PREDICATE *)
predicate minmax'_list_upper_bound (f:'a -> int63) (l:list (arbre 'a)) (bo:bool) (score:int63) =
  forall x. mem x l ->
    match x with
    | N info Nil -> (if bo then (>=) else (<=)) score (f info)
    | N _ l' ->
      exists y. mem y l' /\
        (if bo then (>=) else (<=)) score (minmax' f y bo)
    end

predicate minmax'_list_lower_bound (f:'a -> int63) (l:list (arbre 'a)) (bo:bool) (score:int63) =
  l <> Nil -> exists x. mem x l /\
    match x with
    | N info Nil -> (if bo then (<=) else (>=)) score (f info)
    | N _ l' ->
      forall y. mem y l' ->
        (if bo then (<=) else (>=)) score (minmax' f y bo)
    end

predicate minmax'_upper_bound (f:'a -> int63) (t:arbre 'a) (bo:bool) (score:int63) =
  match t with
  | N info Nil -> score = f info
  | N _ l -> minmax'_list_upper_bound f l bo score
  end
  
predicate minmax'_lower_bound (f:'a -> int63) (t:arbre 'a) (bo:bool) (score:int63) =
  match t with
  | N info Nil -> score = f info
  | N _ l -> minmax'_list_lower_bound f l bo score
  end

(* MINMAX EXTEND *)
lemma minmax'_list_upper_extend_true:
  forall f: 'a -> int63. forall l: list (arbre 'a). forall score0 score1: int63.
    minmax'_list_upper_bound f l true score0 ->
    score1 >= score0 ->
    minmax'_list_upper_bound f l true score1
    
lemma minmax'_list_upper_extend_false:
  forall f: 'a -> int63. forall l: list (arbre 'a). forall score0 score1: int63.
    minmax'_list_upper_bound f l false score0 ->
    score1 <= score0 ->
    minmax'_list_upper_bound f l false score1

lemma minmax'_list_lower_extend_true:
  forall f: 'a -> int63. forall l: list (arbre 'a). forall score0 score1: int63.
    minmax'_list_lower_bound f l true score0 ->
    score1 <= score0 ->
    minmax'_list_lower_bound f l true score1

lemma minmax'_list_lower_extend_false:
  forall f: 'a -> int63. forall l: list (arbre 'a). forall score0 score1: int63.
    minmax'_list_lower_bound f l false score0 ->
    score1 >= score0 ->
    minmax'_list_lower_bound f l false score1



let rec lemma minmax'_list_extendscore_true 
  (f:'a -> int63) (l: list (arbre 'a)) (v v':int63) =
  variant { l }
  requires { 
    let score = minmax'_list f true l v in
    v' >= score
  }
  ensures {
    let score = minmax'_list f true l v in
    minmax'_list f true l v' = v'
  }
  match l with
  | Nil -> ()
  | Cons e l' ->
    let v'' = int63_max v (minmax' f e false) in
    minmax'_list_extendscore_true f l' v'' v'
  end
  
let rec lemma minmax'_list_extendscore_false
  (f:'a -> int63) (l: list (arbre 'a)) (v v':int63) =
  variant { l }
  requires { 
    let score = minmax'_list f false l v in
    v' <= score
  }
  ensures {
    let score = minmax'_list f false l v in
    minmax'_list f false l v' = v'
  }
  match l with
  | Nil -> ()
  | Cons e l' ->
    let v'' = int63_min v (minmax' f e true) in
    minmax'_list_extendscore_false f l' v'' v'
  end

let rec lemma minmax'_list_infscore_true 
  (f:'a -> int63) (l: list (arbre 'a)) (v v':int63) =
  variant { l }
  requires { 
    let score = minmax'_list f true l v in
    v' < score
  }
  ensures {
    let score = minmax'_list f true l v in
    let score' = minmax'_list f true l v' in
    v = score \/ score' = score
  }
  let score = minmax'_list f true l v in
  if v = score then ()
  else
    match l with
    | Nil -> ()
    | Cons e l' ->
      let score = minmax'_list f true l' v in
      let v2 = int63_max v' (minmax' f e false) in
      if (v2>=score) then minmax'_list_infscore_true f l' v2 v'
      else minmax'_list_infscore_true f l' v2 v'
    end
    
let rec lemma minmax'_list_supscore_false 
  (f:'a -> int63) (l: list (arbre 'a)) (v v':int63) =
  variant { l }
  requires { 
    let score = minmax'_list f false l v in
    v' > score
  }
  ensures {
    let score = minmax'_list f false l v in
    let score' = minmax'_list f false l v' in
    v = score \/ score' = score
  }
  let score = minmax'_list f false l v in
  if v = score then ()
  else
    match l with
    | Nil -> ()
    | Cons e l' ->
      let score = minmax'_list f false l' v in
      let v2 = int63_min v' (minmax' f e true) in
      if (v2<=score) then minmax'_list_supscore_false f l' v2 v'
      else minmax'_list_supscore_false f l' v2 v'
    end

(* MINMAX LIST rev l <=> l *)
let rec lemma minmax'_list_rev_l
  (f:'a -> int63) (l:list (arbre 'a)) (bo:bool) (v: int63) =
   variant { l }
   ensures { minmax'_list f bo l v = minmax'_list f bo (reverse l) v }
   ()

let rec lemma minmax'_list_min_int_lower_bound 
  (f:'a -> int63) (l:list (arbre 'a)) =
  variant { l }
  requires { minmax'_list f true l min_int = min_int }
  ensures { minmax'_list_lower_bound f l true min_int }
  match l with
  | Nil -> ()
  | Cons x l' ->
    match l' with
    | Nil -> ()
    | _ -> minmax'_list_min_int_lower_bound f l'
    end
  end

let rec lemma minmax'_list_max_int_lower_bound 
  (f:'a -> int63) (l:list (arbre 'a)) =
  variant { l }
  requires { minmax'_list f false l max_int = max_int }
  ensures { minmax'_list_lower_bound f l false max_int }
  match l with
  | Nil -> ()
  | Cons x l' ->
    match l' with
    | Nil -> ()
    | _ -> minmax'_list_max_int_lower_bound f l'
    end
  end


let rec lemma minmax'_spec (f:'a -> int63) (t:arbre 'a) (bo:bool) : unit =
  variant { t }
  ensures {
    let score = minmax' f t bo in
    minmax'_upper_bound f t bo score /\
    minmax'_lower_bound f t bo score }
  match t with
  | N _ Nil -> ()
  | N _ l -> 
    let score = minmax' f t bo in
    minmax'_list_spec f l bo (if bo then min_int else max_int)
  end
with lemma minmax'_list_spec (f:'a -> int63) (l: list (arbre 'a)) (bo:bool) (v: int63) : unit =
  variant { l }
  ensures {
    let score = minmax'_list f bo l v in
    minmax'_list_upper_bound f l bo score /\
    (v=score \/ minmax'_list_lower_bound f l bo score) }
  match l with
  | Nil -> ()
  | Cons t l' -> 
    minmax'_spec f t (not bo);
    if bo then
      let v' =  int63_max v (minmax' f t (not bo)) in
      minmax'_list_spec f l' bo v'
    else
      let v' =  int63_min v (minmax' f t (not bo)) in
      minmax'_list_spec f l' bo v'
  end
  

let rec minmax (t:arbre 'a) (bo:bool) (f:'a -> int63) =
  variant { height t }
  ensures { result = minmax' f t bo }
  match t with
  | N info Nil -> f info
  | N _ l -> 
    if bo then
      let rec loop ll v =
        variant { ll }
        requires { forall x. mem x ll -> height x < height t }
        ensures { result = minmax'_list f true ll v }
        match ll with
        | Nil -> v
        | Cons e l' ->
          let v' =  int63_max v (minmax e false f) in
          loop l' v'
        end
      in
      loop l min_int
    else
      let rec loop ll v =    
        variant { ll }
        requires { forall x. mem x ll -> height x < height t }
        ensures { result = minmax'_list f false ll v }
        match ll with
        | Nil -> v
        | Cons e l' ->
          let v' =  int63_min v (minmax e true f) in
          loop l' v'
        end
      in
      loop l max_int
  end


(*
let rec function minmax' (f:'a -> int63) (t:arbre 'a) (bo:bool) =
  variant { t }
  match t with
  | N info Nil -> f info
  | N _ l -> 
    minmax'_list f bo l (if bo then min_int else max_int)
  end
with function minmax'_list f bo ll v =
  variant { ll }
  match ll with
  | Nil -> v
  | Cons e l' -> 
    let v' =  (if bo then int63_max else int63_min) v (minmax' f e (not bo)) in
    minmax'_list f bo l' v'
  end
*)

type flag =
  | InfAlpha
  | SupBeta
  | InBounds

predicate flt (f1 f2:flag) =
  match f1, f2 with
  | InfAlpha, _ -> true
  | InBounds, (InBounds|SupBeta) -> true
  | SupBeta, SupBeta -> true
  | _, _ -> false
  end

let rec alphabeta (t:arbre 'a) (bo:bool) (f:'a -> int63) (a b:int63) : (res: int63 , ghost bound: flag) =
  variant { height t }
  requires { a < b }
  ensures {
    match bound with
    | InBounds -> a <= res <= b /\ res = minmax' f t bo
    | InfAlpha -> minmax' f t bo <= res <= a
    | SupBeta  -> minmax' f t bo >= res >= b
    end    
  }
  ensures { a = min_int /\ b = max_int -> res = minmax' f t bo }
  match t with
  | N info Nil -> 
    let v = f info in
    v, (if v<a then InfAlpha else if v>b then SupBeta else InBounds)
  | N _ l -> 
    if bo then
      let rec loop ll v a (ghost fv : flag) (ghost l0): (res : int63, ghost bound: flag) =
        variant { ll }
        requires { forall x. mem x ll -> height x < height t }
        requires { l = reverse l0 ++ ll }
        requires { a < b }
        requires {
          match fv with
          | InBounds -> a = v <= b /\ v =  minmax'_list f true l0 min_int
          | InfAlpha -> minmax'_list f true l0 min_int <= v <= a
          | SupBeta  -> minmax'_list f true l0 min_int >= v >= b
          end
        }
        ensures { 
          match bound with
          | InBounds -> a <= res <= b /\ res = minmax'_list f true l min_int
          | InfAlpha -> minmax'_list f true l min_int <= res <= a
          | SupBeta  -> minmax'_list f true l min_int >= res >= b
          end
        }
        ensures { flt fv bound }
        match ll with
        | Nil -> v, fv
        | Cons e l' -> 
          let (r,f) = alphabeta e (not bo) f a b in
          let v', f' =
            if r > v then
              r,f
            else
              v, fv
          in
          if v' >= b then (v', SupBeta)
          else
            loop l' v' (int63_max v' a) f' (Cons e l0)
        end
      in
      loop l min_int a InfAlpha Nil
    else
      let rec loop ll v b (ghost fv : flag) (ghost l0) : (res : int63, ghost bound: flag) =
        variant { ll }
        requires { forall x. mem x ll -> height x < height t }
        requires { l = reverse l0 ++ ll }
        requires { a < b }
        requires {
          match fv with
          | InBounds -> a <= v = b /\ v =  minmax'_list f false l0 max_int
          | InfAlpha -> minmax'_list f false l0 max_int <= v <= a
          | SupBeta  -> minmax'_list f false l0 max_int >= v >= b
          end
        }
        ensures { 
          match bound with
          | InBounds -> a <= res <= b /\ res = minmax'_list f false l max_int 
          | InfAlpha -> minmax'_list f false l max_int  <= res <= a
          | SupBeta  -> minmax'_list f false l max_int  >= res >= b
          end
        }
        ensures { flt bound fv }
        match ll with
        | Nil -> v, fv
        | Cons e l' ->
          let (r,f) = alphabeta e (not bo) f a b in
          let v', f' =
            if r < v then
              r,f
            else
              v, fv
          in
          if v' <= a then (v', InfAlpha)
          else
            loop l' v' (int63_min v' b) f' (Cons e l0)
        end
      in
      loop l max_int b SupBeta Nil
  end